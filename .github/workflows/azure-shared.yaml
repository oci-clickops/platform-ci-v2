name: Azure Terraform Shared

on:
  workflow_call:
    inputs:
      mode:
        required: true
        type: string
      region:
        required: false
        type: string
        default: "fra"
      config_subpath:
        required: false
        type: string
        default: "azure/fra"
      drift_label:
        required: false
        type: string
        default: ""
      drift_title:
        required: false
        type: string
        default: ""
      slack_prefix:
        required: false
        type: string
        default: "Azure"
      slack_webhook_secret:
        required: false
        type: string
        default: "SLACK_WEBHOOK_URL"
      slack_channel:
        required: false
        type: string
        default: ""
      slack_mention:
        required: false
        type: string
        default: ""
    secrets: {}

jobs:
  run:
    name: "Azure shared workflow"
    runs-on: self-hosted
    permissions:
      contents: read
      pull-requests: write
      issues: write
      packages: read
      repository-projects: read
    env:
      MODE: ${{ inputs.mode }}
      REGION_INPUT: ${{ inputs.region }}
      CONFIG_SUBPATH: ${{ inputs.config_subpath }}
      DRIFT_LABEL: ${{ inputs.drift_label }}
      DRIFT_TITLE: ${{ inputs.drift_title }}
      SLACK_PREFIX: ${{ inputs.slack_prefix }}
      SLACK_CHANNEL_LABEL: ${{ inputs.slack_channel }}
      SLACK_MENTION_TEXT: ${{ inputs.slack_mention }}
      SLACK_WEBHOOK_SECRET_NAME: ${{ inputs.slack_webhook_secret }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Clone Azure Orchestrator
      env:
        GH_TOKEN: ${{ secrets.GH_PAT }}
      run: git clone https://${GH_TOKEN}@github.com/iblake/clickops-orchestrator-azure.git ORCH

    - name: Load Runner Environment
      run: |
        source /opt/actions-runner/.github-runner-env
        echo "‚úÖ ARM credentials loaded from runner environment"

    - name: Replace Subscription ID in config files
      run: |
        source /opt/actions-runner/.github-runner-env
        CONFIG_DIR=${{ github.workspace }}/${CONFIG_SUBPATH}
        find "$CONFIG_DIR" -name '*.json' -exec sed -i "s|__SUBSCRIPTION_ID__|$ARM_SUBSCRIPTION_ID|g" {} \;
        echo "‚úÖ Subscription ID replaced in configuration files"

    - name: Azure CLI Login
      run: |
        source /opt/actions-runner/.github-runner-env
        az login --service-principal \
          --username "$ARM_CLIENT_ID" \
          --password "$ARM_CLIENT_SECRET" \
          --tenant "$ARM_TENANT_ID" > /dev/null 2>&1
        az account set --subscription "$ARM_SUBSCRIPTION_ID" > /dev/null 2>&1
        echo "‚úÖ Azure login successful"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.1
        terraform_wrapper: true

    - name: Render versions.tf from template
      run: |
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        envsubst < versions.tf.template > versions.tf
        terraform fmt versions.tf

    - name: Terraform Init
      run: |
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        terraform init

    - name: Terraform Format
      id: format
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request' }}
      run: |
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        terraform fmt -check

    - name: Terraform Validate
      id: validate
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request' }}
      run: |
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        terraform validate -no-color

    - name: Validate SSH Key Availability (PR only)
      id: ssh-key
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request' }}
      run: |
        SSH_KEY_PATH="$HOME/.ssh/azure_vm_key.pub"
        if [ ! -f "$SSH_KEY_PATH" ]; then
          echo "SSH public key not found at $SSH_KEY_PATH"
          echo "Run: ssh-keygen -t rsa -b 4096 -f $HOME/.ssh/azure_vm_key -N ''"
          exit 1
        fi
        echo "SSH key found and ready"
        echo "SSH_PUBLIC_KEY=$(cat $SSH_KEY_PATH)" >> $GITHUB_OUTPUT

    - name: Mask SSH Key in logs
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request' }}
      run: |
        SSH_KEY=$(cat $HOME/.ssh/azure_vm_key.pub)
        echo "::add-mask::$SSH_KEY"

    - name: Terraform Plan
      id: plan
      run: |
        set -euo pipefail
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        CONFIG_DIR=${{ github.workspace }}/${CONFIG_SUBPATH}
        VARS=$(find "$CONFIG_DIR" -name '*.json')
        echo "Planning with files:\n$VARS"

        REFRESH_FLAG=""
        if [ "$MODE" = "drift" ]; then
          REFRESH_FLAG="-refresh-only"
        fi

        set +e
        PLAN_OUTPUT=$(terraform plan $REFRESH_FLAG -detailed-exitcode -no-color $(for i in $VARS; do echo "-var-file $i"; done) -out=tfplan.binary 2>&1)
        PLAN_EXIT_CODE=$?
        set -e

        if [ "$PLAN_EXIT_CODE" -eq 1 ]; then
          echo "$PLAN_OUTPUT"
          exit 1
        fi

        SANITIZED_PLAN=$(echo "$PLAN_OUTPUT" | \
          sed -E "s|/subscriptions/[a-f0-9-]{36}|/subscriptions/***|g" | \
          sed -E "s|\"tenant_id\"[[:space:]]*=[[:space:]]*\"[a-f0-9-]{36}\"|\"tenant_id\" = \"***\"|g" | \
          sed -E "s|\"subscription_id\"[[:space:]]*=[[:space:]]*\"[a-f0-9-]{36}\"|\"subscription_id\" = \"***\"|g" | \
          sed -E "s|ssh-rsa AAAA[A-Za-z0-9+/=]{300,}|ssh-rsa ***REDACTED***|g" | \
          sed -E "s|-----BEGIN PUBLIC KEY-----[^-]*-----END PUBLIC KEY-----|***PUBLIC_KEY_REDACTED***|g")

        {
          echo "plan_output<<'EOF'"
          echo "$SANITIZED_PLAN"
          echo "EOF"
          echo "plan_exit_code=$PLAN_EXIT_CODE"
          if [ "$MODE" = "drift" ]; then
            if [ "$PLAN_EXIT_CODE" -eq 2 ]; then
              echo "plan_status=drift"
            else
              echo "plan_status=clean"
            fi
          fi
        } >> "$GITHUB_OUTPUT"

    - name: Post PR comment
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request' }}
      uses: actions/github-script@v7
      env:
        PLAN: ${{ steps.plan.outputs.plan_output }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `#### Terraform Format üñå \`${{ steps.format.outcome }}\`
          #### Terraform Validate ü§ñ \`${{ steps.validate.outcome }}\`
          #### Terraform Plan üìñ \`${{ steps.plan.outcome }}\`

          <details><summary>Show Plan</summary>

          \`\`\`terraform
          ${process.env.PLAN}
          \`\`\`

          </details>

          *Pushed by: @${{ github.actor }}*`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

    - name: Upload plan log
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: azure-terraform-plan
        path: ${{ github.workspace }}/ORCH/tfplan.binary
        if-no-files-found: ignore

    - name: Notify Slack on Plan success
      if: ${{ inputs.mode == 'pr' && success() && github.event_name == 'pull_request' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets[inputs.slack_webhook_secret] }}
      run: |
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "Slack webhook not provided, skipping notification"
          exit 0
        fi
        CHANNEL_LINE=""
        if [ -n "$SLACK_CHANNEL_LABEL" ]; then
          CHANNEL_LINE="Channel: $SLACK_CHANNEL_LABEL\n"
        fi
        MENTION_LINE=""
        if [ -n "$SLACK_MENTION_TEXT" ]; then
          MENTION_LINE="$SLACK_MENTION_TEXT\n"
        fi
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚úÖ ${SLACK_PREFIX} Terraform plan succeeded\",
            \"blocks\": [{
              \"type\": \"section\",
              \"text\": {
                \"type\": \"mrkdwn\",
                \"text\": \"${MENTION_LINE}*‚úÖ ${SLACK_PREFIX} Terraform Plan Succeeded*\\n*PR:* <${{ github.event.pull_request.html_url }}|#${{ github.event.number }} - ${{ github.event.pull_request.title }}>\\n*Author:* @${{ github.actor }}\\n*Status:* Format ${${{ steps.format.outcome }}:-SKIPPED} | Validate ${${{ steps.validate.outcome }}:-SKIPPED} | Plan ${{ steps.plan.outcome }}\\n${CHANNEL_LINE}\"
              }
            }]
          }"

    - name: Notify Slack on failure
      if: ${{ inputs.mode == 'pr' && failure() }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets[inputs.slack_webhook_secret] }}
      run: |
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "Slack webhook not provided, skipping notification"
          exit 0
        fi
        MENTION_LINE=""
        if [ -n "$SLACK_MENTION_TEXT" ]; then
          MENTION_LINE="$SLACK_MENTION_TEXT\n"
        fi
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚ùå ${SLACK_PREFIX} Terraform workflow failed\",
            \"blocks\": [{
              \"type\": \"section\",
              \"text\": {
                \"type\": \"mrkdwn\",
                \"text\": \"${MENTION_LINE}*‚ùå ${SLACK_PREFIX} Terraform Workflow Failed*\\n*PR:* <${{ github.event.pull_request.html_url }}|#${{ github.event.number }}>\\n*Logs:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow logs>\\n*Author:* @${{ github.actor }}\"
              }
            }]
          }"

    - name: Terraform Apply (on PR merge)
      id: apply
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request_target' && github.event.action == 'closed' && github.event.pull_request.merged == true }}
      run: |
        source /opt/actions-runner/.github-runner-env
        cd ${{ github.workspace }}/ORCH
        CONFIG_DIR=${{ github.workspace }}/${CONFIG_SUBPATH}
        VARS=$(find "$CONFIG_DIR" -name '*.json')
        terraform apply -auto-approve $(for i in $VARS; do echo "-var-file $i"; done)

    - name: Get deployed resources info
      id: resources
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request_target' && github.event.action == 'closed' && github.event.pull_request.merged == true && success() }}
      run: |
        cd ${{ github.workspace }}/ORCH
        CONFIG_DIR=${{ github.workspace }}/${CONFIG_SUBPATH}
        VMS=$(find "$CONFIG_DIR" -name 'compute*.json' -exec jq -r '.virtual_machines | to_entries[] | "‚Ä¢ " + .value.name' {} \; 2>/dev/null | sort -u)
        VNETS=$(find "$CONFIG_DIR" -name '*network.json' -not -name '*security*' -exec jq -r '.networks | to_entries[] | "‚Ä¢ " + .value.name + " (" + .value.cidr + ")"' {} \; 2>/dev/null | sort -u)
        NSGS=$(find "$CONFIG_DIR" -name '*security*.json' -exec jq -r '.security_groups | keys[] | "‚Ä¢ " + .' {} \; 2>/dev/null | sort -u)
        RGS=$(find "$CONFIG_DIR" -name '*resource*.json' -exec jq -r '.resource_groups | to_entries[] | "‚Ä¢ " + .value.name + " [" + .value.location + "]"' {} \; 2>/dev/null | sort -u)
        RG_NAME=$(jq -r '.resource_groups | to_entries[0].value.name' "$CONFIG_DIR"/project-resource-groups.json)
        PUBLIC_IPS=$(az network public-ip list --resource-group "$RG_NAME" --query "[].{name:name, ip:ipAddress}" -o tsv 2>/dev/null | awk '{print "‚Ä¢ " $1 ": " $2}' || echo "")
        echo "resources<<EOF" >> $GITHUB_OUTPUT
        echo "Resource Groups:" >> $GITHUB_OUTPUT
        echo "${RGS:-  None}" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "Virtual Networks:" >> $GITHUB_OUTPUT
        echo "${VNETS:-  None}" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "Network Security Groups:" >> $GITHUB_OUTPUT
        echo "${NSGS:-  None}" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "Virtual Machines:" >> $GITHUB_OUTPUT
        echo "${VMS:-  None}" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "Public IPs:" >> $GITHUB_OUTPUT
        echo "${PUBLIC_IPS:-  Retrieving...}" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Notify Slack on Apply success
      if: ${{ inputs.mode == 'pr' && github.event_name == 'pull_request_target' && github.event.action == 'closed' && github.event.pull_request.merged == true && success() }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets[inputs.slack_webhook_secret] }}
        RESOURCES: ${{ steps.resources.outputs.resources }}
      run: |
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "Slack webhook not provided, skipping notification"
          exit 0
        fi
        MENTION_LINE=""
        if [ -n "$SLACK_MENTION_TEXT" ]; then
          MENTION_LINE="$SLACK_MENTION_TEXT\n"
        fi
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚úÖ ${SLACK_PREFIX} infrastructure deployed\",
            \"blocks\": [{
              \"type\": \"section\",
              \"text\": {
                \"type\": \"mrkdwn\",
                \"text\": \"${MENTION_LINE}*‚úÖ ${SLACK_PREFIX} Infrastructure Deployed*\\n*PR:* <${{ github.event.pull_request.html_url }}|#${{ github.event.number }} - ${{ github.event.pull_request.title }}>\\n*Author:* @${{ github.actor }}\\n*Region:* ${REGION_INPUT}\\n\\n*Deployed Resources:*\\n\`\`\`\n${RESOURCES}\n\`\`\`\"
              }
            }, {
              \"type\": \"context\",
              \"elements\": [{
                \"type\": \"mrkdwn\",
                \"text\": \"<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View deployment logs>\"
              }]
            }]
          }"

    - name: Report drift (issue)
      if: ${{ inputs.mode == 'drift' && inputs.drift_label != '' && steps.plan.outputs.plan_status == 'drift' }}
      uses: actions/github-script@v7
      env:
        PLAN: ${{ steps.plan.outputs.plan_output }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const label = process.env.DRIFT_LABEL;
          const title = process.env.DRIFT_TITLE || `[drift] ${process.env.SLACK_PREFIX}-${process.env.REGION_INPUT}`;
          const body = `‚ö†Ô∏è Drift detected for ${title}\n\nWorkflow: ${context.workflow}\nRun: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n\u0060\u0060\u0060terraform\n${process.env.PLAN}\n\u0060\u0060\u0060`;

          async function ensureLabel() {
            try {
              await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: label });
            } catch (error) {
              if (error.status === 404) {
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name: label, color: 'fbca04', description: 'Terraform drift detected' });
              } else {
                throw error;
              }
            }
          }

          await ensureLabel();

          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: label,
            state: 'open',
            per_page: 1
          });

          if (issues.data.length) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issues.data[0].number,
              body
            });
          } else {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              labels: [label],
              body
            });
          }

    - name: Close drift issue if clean
      if: ${{ inputs.mode == 'drift' && inputs.drift_label != '' && steps.plan.outputs.plan_status == 'clean' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const label = process.env.DRIFT_LABEL;
          const title = process.env.DRIFT_TITLE || `[drift] ${process.env.SLACK_PREFIX}-${process.env.REGION_INPUT}`;
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: label,
            state: 'open',
            per_page: 1
          });

          if (!issues.data.length) {
            return;
          }

          const issue = issues.data[0];
          const body = `‚úÖ No drift for ${title} (workflow ${context.workflow} run ${context.runId}). Closing incident.`;
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issue.number,
            body
          });
          await github.rest.issues.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issue.number,
            state: 'closed'
          });

    - name: Notify Slack on drift
      if: ${{ inputs.mode == 'drift' && steps.plan.outputs.plan_status == 'drift' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets[inputs.slack_webhook_secret] }}
      run: |
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "Slack webhook not provided, skipping notification"
          exit 0
        fi
        PLAN_OUTPUT=$(cat <<'EOP'
${{ steps.plan.outputs.plan_output }}
EOP
)
        MENTION_LINE=""
        if [ -n "$SLACK_MENTION_TEXT" ]; then
          MENTION_LINE="$SLACK_MENTION_TEXT\n"
        fi
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚ö†Ô∏è Drift detected in ${SLACK_PREFIX} ${REGION_INPUT}\",
            \"blocks\": [{
              \"type\": \"section\",
              \"text\": {
